# =============================================================================
# AI CREDIT PRE-APPROVAL BACKEND SERVICE
# =============================================================================
# 
# This deployment creates the main backend orchestration service that coordinates
# all AI agents and integrates with Bank of Anthos microservices to provide
# comprehensive credit pre-approval functionality.
#
# FEATURES:
# - Intelligent retry logic with exponential backoff
# - In-memory caching with configurable TTL
# - Graceful degradation with fallback data
# - AI agent orchestration (Risk, Terms, Perks, Challenger, Policy)
# - Real-time transaction analysis and spending categorization
# - Comprehensive credit scoring algorithm
# - CORS support for frontend integration
#
# ARCHITECTURE:
# - Backend: Python Flask with advanced reliability features
# - AI Orchestration: Coordinates 6 AI agents with health checks
# - Data Integration: Bank of Anthos services (userservice, balancereader, transactionhistory)
# - Caching Layer: In-memory cache with TTL for performance
# - Error Handling: Circuit breaker pattern with fallback responses
#
# AI AGENT INTEGRATION:
# - Risk Agent: Credit scoring and approval decisions with Gemini reasoning
# - Terms Agent: APR, credit limits, and loan terms generation
# - Perks Agent: Personalized cashback and rewards based on spending patterns
# - Challenger Agent: Bank profitability optimization and counter-offers
# - Policy Agent: Legal document generation with compliance checks
# - MCP Server: Banking policies and regulatory requirements
#
# DEPLOYMENT:
# kubectl apply -f deployments/backend/deploy-backend-service.yaml
#
# =============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-service-code
  namespace: default
  labels:
    app: backend-service
    component: ai-orchestration-backend
    version: v1.0.0
data:
  app.py: |
    #!/usr/bin/env python3
    """
    AI Credit Pre-Approval Backend Service
    =====================================
    
    Main orchestration service that coordinates AI agents and integrates with
    Bank of Anthos microservices to provide comprehensive credit pre-approval.
    
    Features:
    - AI Agent Orchestration (Risk, Terms, Perks, Challenger, Policy)
    - Real-time transaction analysis and spending categorization
    - Intelligent caching and retry mechanisms
    - Comprehensive credit scoring algorithm
    - Bank profitability optimization with arbiter logic
    """
    
    import os
    import json
    import logging
    import requests
    import time
    import hashlib
    import psycopg2
    from flask import Flask, request, jsonify
    from flask_cors import CORS
    from datetime import datetime, timedelta
    from requests.adapters import HTTPAdapter
    from urllib3.util.retry import Retry
    
    # ==========================================================================
    # LOGGING AND APPLICATION SETUP
    # ==========================================================================
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)
    
    app = Flask(__name__)
    CORS(app)  # Enable CORS for frontend integration
    
    # ==========================================================================
    # CONFIGURATION
    # ==========================================================================
    
    # In-memory cache configuration
    cache = {}
    CACHE_TTL = 300  # 5 minutes cache TTL
    
    # Merchant mapping for transaction categorization (matches database merchant accounts)
    MERCHANTS = {
        '2001001001': {'name': 'Starbucks Coffee', 'category': 'Coffee & Cafes'},
        '2001001002': {'name': 'Whole Foods Market', 'category': 'Groceries'},
        '2001001003': {'name': 'Amazon.com', 'category': 'Online Shopping'},
        '2001001004': {'name': 'Shell Gas Station', 'category': 'Gas & Fuel'},
        '2001001005': {'name': 'McDonald\'s', 'category': 'Fast Food'},
        '2001001006': {'name': 'Target', 'category': 'Retail Stores'},
        '2001001007': {'name': 'Uber', 'category': 'Transportation'},
        '2001001008': {'name': 'Netflix', 'category': 'Subscriptions'},
        '2001001009': {'name': 'Best Buy', 'category': 'Electronics'},
        '2001001010': {'name': 'Chipotle Mexican Grill', 'category': 'Restaurants'},
        '2001001011': {'name': 'CVS Pharmacy', 'category': 'Health & Wellness'},
        '2001001012': {'name': 'Spotify', 'category': 'Subscriptions'},
        '2001001013': {'name': 'Apple Store', 'category': 'Electronics'},
        '2001001014': {'name': 'Costco Wholesale', 'category': 'Wholesale'},
        '2001001015': {'name': 'Planet Fitness', 'category': 'Fitness & Health'},
        '2001001016': {'name': 'Panera Bread', 'category': 'Restaurants'},
        '2001001017': {'name': 'Home Depot', 'category': 'Home Improvement'},
        '2001001018': {'name': 'Safeway', 'category': 'Groceries'},
        '2001001019': {'name': 'Lyft', 'category': 'Transportation'},
        '2001001020': {'name': 'Adobe Creative Cloud', 'category': 'Subscriptions'}
    }
    
    # Bank of Anthos service endpoints (fetching from main system in real-time)
    SERVICES = {
        'userservice': 'http://34.41.156.37',
        'balancereader': 'http://34.41.156.37',  
        'transactionhistory': 'http://34.41.156.37'
    }
    
    # AI Agent service endpoints
    AI_AGENTS = {
        'perks': 'http://perks-agent-real:8085',
        'risk': 'http://enhanced-risk-agent:8087',
        'terms': 'http://terms-agent-simple:8086',
        'challenger': 'http://challenger-agent:8088',
        'policy': 'http://enhanced-policy-agent:8090'
    }
    
    # Demo user accounts for testing
    DEMO_USERS = {
        'testuser': {'account_id': '1011226111', 'username': 'testuser', 'password': 'bankofanthos'},
        'alice': {'account_id': '1033623433', 'username': 'alice', 'password': 'bankofanthos'},
        'bob': {'account_id': '1055757655', 'username': 'bob', 'password': 'bankofanthos'},
        'eve': {'account_id': '1077889977', 'username': 'eve', 'password': 'bankofanthos'}
    }
    
    # ==========================================================================
    # RELIABILITY & NETWORKING
    # ==========================================================================
    
    def create_reliable_session():
        """
        Creates a requests session with intelligent retry logic and exponential backoff
        """
        session = requests.Session()
        
        # Retry strategy configuration
        retry_strategy = Retry(
            total=2,  # Maximum retry attempts
            status_forcelist=[429, 500, 502, 503, 504],  # HTTP status codes to retry
            allowed_methods=["HEAD", "GET", "POST"],  # HTTP methods to retry
            backoff_factor=0.5  # Exponential backoff: 0.5s, 1s delays
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        return session
    
    # Global session instance
    session = create_reliable_session()
    
    # ==========================================================================
    # CACHING UTILITIES
    # ==========================================================================
    
    def get_cache_key(prefix, *args):
        """Generate consistent cache keys"""
        key_data = f"{prefix}:{':'.join(str(arg) for arg in args)}"
        return hashlib.md5(key_data.encode()).hexdigest()
    
    def get_from_cache(key):
        """Retrieve data from cache if not expired"""
        if key in cache:
            data, timestamp = cache[key]
            if datetime.now() - timestamp < timedelta(seconds=CACHE_TTL):
                logger.info(f"‚úÖ Cache hit for {key}")
                return data
            else:
                del cache[key]
        return None
    
    def set_cache(key, data):
        """Store data in cache with timestamp"""
        cache[key] = (data, datetime.now())
        logger.info(f"üíæ Cached response for {key}")
    
    # ==========================================================================
    # DIRECT DATABASE CONNECTION (BYPASS USERSERVICE AUTHENTICATION ISSUES)
    # ==========================================================================
    
    # Database configurations
    LEDGER_DB_CONFIG = {
        'host': 'ledger-db',
        'database': 'postgresdb',
        'user': 'admin',
        'password': 'password',
        'port': '5432'
    }
    
    ACCOUNTS_DB_CONFIG = {
        'host': 'accounts-db',
        'database': 'accounts-db',
        'user': 'accounts-admin',
        'password': 'accounts-pwd',
        'port': '5432'
    }
    
    def get_direct_balance(username):
        """Get balance directly from database (bypass userservice)"""
        try:
            user_data = DEMO_USERS.get(username, DEMO_USERS['testuser'])
            account_id = user_data['account_id']
            
            conn = psycopg2.connect(**LEDGER_DB_CONFIG)
            cur = conn.cursor()
            
            # Calculate balance from transactions
            cur.execute("""
                SELECT 
                    COALESCE(SUM(CASE WHEN to_acct = %s THEN amount ELSE 0 END), 0) -
                    COALESCE(SUM(CASE WHEN from_acct = %s THEN amount ELSE 0 END), 0) as balance
                FROM transactions 
                WHERE from_acct = %s OR to_acct = %s
            """, (account_id, account_id, account_id, account_id))
            
            result = cur.fetchone()
            balance = float(result[0]) / 100.0 if result and result[0] else 0.0
            
            conn.close()
            logger.info(f"üí∞ Direct DB balance for {username}: ${balance:.2f}")
            return balance
            
        except Exception as e:
            logger.error(f"‚ùå Direct balance query failed: {e}")
            return 0.0
    
    def get_direct_transactions(username):
        """Get transactions directly from database (bypass userservice)"""
        try:
            user_data = DEMO_USERS.get(username, DEMO_USERS['testuser'])
            account_id = user_data['account_id']
            
            conn = psycopg2.connect(**LEDGER_DB_CONFIG)
            cur = conn.cursor()
            
            # Get recent transactions
            cur.execute("""
                SELECT from_acct, to_acct, amount, timestamp
                FROM transactions 
                WHERE from_acct = %s OR to_acct = %s
                ORDER BY timestamp DESC
                LIMIT 100
            """, (account_id, account_id))
            
            transactions = []
            for row in cur.fetchall():
                from_acct, to_acct, amount, timestamp = row
                transactions.append({
                    'accountId': account_id,
                    'fromAccountId': from_acct,
                    'toAccountId': to_acct,
                    'amount': amount,
                    'timestamp': timestamp.isoformat() if timestamp else datetime.now().isoformat()
                })
            
            conn.close()
            logger.info(f"üìä Direct DB transactions for {username}: {len(transactions)} found")
            return transactions
            
        except Exception as e:
            logger.error(f"‚ùå Direct transactions query failed: {e}")
            return []
    
    # ==========================================================================
    # BANK OF ANTHOS INTEGRATION (WITH FALLBACK TO DIRECT DB)
    # ==========================================================================
    
    def get_auth_token(username):
        """
        Authenticate with Bank of Anthos userservice and retrieve JWT token
        """
        cache_key = get_cache_key("auth", username)
        cached_token = get_from_cache(cache_key)
        if cached_token:
            return cached_token
        
        try:
            user_data = DEMO_USERS.get(username, DEMO_USERS['testuser'])
            logger.info(f"üîê Authenticating user: {user_data['username']}")
            
            response = session.get(
                f"{SERVICES['userservice']}/login",
                params={'username': user_data['username'], 'password': user_data['password']},
                timeout=3
            )
            
            logger.info(f"üîê Auth response: {response.status_code}")
            if response.status_code == 200:
                try:
                    auth_data = response.json()
                    token = auth_data.get('token', response.text.strip())
                except:
                    token = response.text.strip()
                
                logger.info(f"‚úÖ Authentication successful: {token[:20]}...")
                set_cache(cache_key, token)
                return token
            else:
                logger.error(f"‚ùå Authentication failed: {response.status_code} - {response.text}")
                return None
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Auth network error: {e}")
            return None
        except Exception as e:
            logger.error(f"‚ùå Auth error: {e}")
            return None
    
    def get_balance(username):
        """
        Retrieve account balance from main Bank of Anthos system in real-time
        """
        cache_key = get_cache_key("balance", username)
        cached_balance = get_from_cache(cache_key)
        if cached_balance is not None:
            return cached_balance
        
        try:
            # Get auth token from main Bank system
            token = get_auth_token(username)
            if not token:
                logger.warning(f"‚ö†Ô∏è Auth failed for {username}, using direct DB fallback")
                balance = get_direct_balance(username)
                set_cache(cache_key, balance)
                return balance
            
            # Fetch balance from main Bank system
            response = session.get(
                f"{SERVICES['balancereader']}/balances/{DEMO_USERS[username]['account_id']}",
                headers={'Authorization': f'Bearer {token}'},
                timeout=3
            )
            
            if response.status_code == 200:
                data = response.json()
                balance = data.get('balance', 0) / 100  # Convert from cents
                logger.info(f"üí∞ Real-time balance from main system: ${balance}")
                set_cache(cache_key, balance)
                return balance
            else:
                logger.warning(f"‚ö†Ô∏è Balance API error {response.status_code}, using direct DB fallback")
                balance = get_direct_balance(username)
                set_cache(cache_key, balance)
                return balance
                
        except Exception as e:
            logger.error(f"‚ùå Balance fetch error: {e}, using direct DB fallback")
            balance = get_direct_balance(username)
            set_cache(cache_key, balance)
            return balance
    
    def get_transactions(username):
        """
        Retrieve transaction history from main Bank of Anthos system in real-time
        """
        cache_key = get_cache_key("transactions", username)
        cached_transactions = get_from_cache(cache_key)
        if cached_transactions is not None:
            return cached_transactions
        
        try:
            # Get auth token from main Bank system
            token = get_auth_token(username)
            if not token:
                logger.warning(f"‚ö†Ô∏è Auth failed for {username}, using direct DB fallback")
                transactions = get_direct_transactions(username)
                set_cache(cache_key, transactions)
                return transactions
            
            # Fetch transactions from main Bank system
            response = session.get(
                f"{SERVICES['transactionhistory']}/transactions/{DEMO_USERS[username]['account_id']}",
                headers={'Authorization': f'Bearer {token}'},
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                transactions = data.get('transactions', [])
                logger.info(f"üìä Real-time transactions from main system: {len(transactions)} found")
                set_cache(cache_key, transactions)
                return transactions
            else:
                logger.warning(f"‚ö†Ô∏è Transactions API error {response.status_code}, using direct DB fallback")
                transactions = get_direct_transactions(username)
                set_cache(cache_key, transactions)
                return transactions
                
        except Exception as e:
            logger.error(f"‚ùå Transactions fetch error: {e}, using direct DB fallback")
            transactions = get_direct_transactions(username)
            set_cache(cache_key, transactions)
            return transactions
    
    # ==========================================================================
    # SPENDING ANALYSIS
    # ==========================================================================
    
    def analyze_spending(transactions, username):
        """
        Analyze transactions and categorize spending patterns
        """
        if not transactions:
            return {}
            
        categories = {}
        account_id = DEMO_USERS[username]['account_id']
        
        for tx in transactions:
            try:
                # Handle both API format (fromAccountNum) and direct DB format (fromAccountId)
                from_account = tx.get('fromAccountNum') or tx.get('fromAccountId')
                to_account = tx.get('toAccountNum') or tx.get('toAccountId')
                
                if from_account == account_id:
                    amount = tx['amount'] / 100  # Convert from cents
                    
                    merchant = MERCHANTS.get(to_account)
                    if merchant:
                        category = merchant['category']
                        if category not in categories:
                            categories[category] = {'total': 0, 'count': 0, 'amount': 0}
                        categories[category]['total'] += amount
                        categories[category]['count'] += 1
                        categories[category]['amount'] = amount
                    else:
                        if 'Other' not in categories:
                            categories['Other'] = {'total': 0, 'count': 0, 'amount': 0}
                        categories['Other']['total'] += amount
                        categories['Other']['count'] += 1
                        categories['Other']['amount'] = amount
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Error processing transaction: {e}")
                continue
        
        logger.info(f"üìä Analyzed spending: {len(categories)} categories")
        return categories
    
    # ==========================================================================
    # AI AGENT INTEGRATION
    # ==========================================================================
    
    def call_ai_agent(agent_name, endpoint, data, timeout=5):
        """
        Call an AI agent with data and handle responses
        """
        try:
            if agent_name not in AI_AGENTS:
                logger.warning(f"‚ö†Ô∏è Unknown AI agent: {agent_name}")
                return None
                
            url = f"{AI_AGENTS[agent_name]}/{endpoint}"
            
            if endpoint == 'health':
                response = session.get(url, timeout=timeout)
            else:
                response = session.post(url, json=data, timeout=timeout)
                
            if response.status_code == 200:
                result = response.json()
                logger.info(f"‚úÖ {agent_name} agent responded successfully")
                return result
            else:
                logger.warning(f"‚ùå {agent_name} agent returned {response.status_code}")
                return None
                
        except requests.exceptions.RequestException as e:
            logger.warning(f"‚ùå {agent_name} agent network error: {e}")
            return None
        except Exception as e:
            logger.warning(f"‚ùå {agent_name} agent error: {e}")
            return None
    
    def get_ai_insights(financial_data):
        """
        Orchestrate all AI agents to provide comprehensive credit insights
        """
        logger.info("ü§ñ Starting AI agent orchestration...")
        
        insights = {
            'perks': None,
            'risk_assessment': None,
            'risk_decision': None,
            'terms': None,
            'challenger_analysis': None,
            'final_decision': None,
            'policy_documents': None,
            'ai_agents_status': {}
        }
        
        # Health check all agents first
        for agent_name in AI_AGENTS:
            health_check = call_ai_agent(agent_name, 'health', {}, timeout=3)
            insights['ai_agents_status'][agent_name] = 'healthy' if health_check else 'unavailable'
            logger.info(f"üè• {agent_name} agent: {insights['ai_agents_status'][agent_name]}")
        
        # STEP 1: Risk Assessment and Approval Decision
        if insights['ai_agents_status']['risk'] == 'healthy':
            logger.info("üéØ Step 1: Risk Agent Assessment...")
            
            # Get basic risk assessment (needed by terms agent)
            risk_payload = {
                'user_id': financial_data.get('username', 'testuser'),
                'months': 6
            }
            risk_data = call_ai_agent('risk', 'assess', risk_payload)
            if risk_data:
                insights['risk_assessment'] = risk_data
                logger.info(f"üìä Risk assessment completed: {risk_data.get('tier', 'N/A')} tier")
                
            # Get approval decision with Gemini reasoning
            approval_payload = {
                'user_id': financial_data.get('username', 'testuser'),
                'spending_data': financial_data
            }
            approval_decision = call_ai_agent('risk', 'approve', approval_payload)
            if approval_decision:
                insights['risk_decision'] = approval_decision
                logger.info(f"üéØ Risk Agent Decision: {approval_decision.get('decision')} - {approval_decision.get('risk_level')}")
                
                # Only proceed with other agents if approved
                if approval_decision.get('decision') not in ['REJECTED']:
                    insights['application_approved'] = True
                    logger.info("‚úÖ Application approved by Risk Agent - proceeding with other agents")
                else:
                    insights['application_approved'] = False
                    logger.info("‚ùå Application rejected by Risk Agent - skipping other agents")
                    return insights  # Early return for rejected applications
        
        # STEP 2: Perks Agent - Personalized Rewards
        if insights['ai_agents_status']['perks'] == 'healthy':
            logger.info("üéÅ Step 2: Perks Agent - Generating personalized rewards...")
            
            perks_payload = {
                'user_data': {
                    'balance': financial_data.get('current_balance', 0),
                    'user_id': 'testuser'
                },
                'spending_analysis': {
                    'top_categories': [
                        {'category': cat, 'amount': data.get('total', 0), 'percentage': (data.get('total', 0) / max(financial_data.get('total_spending', 1), 1)) * 100}
                        for cat, data in sorted(financial_data.get('spending_categories', {}).items(), key=lambda x: x[1].get('total', 0), reverse=True)[:5]
                    ],
                    'total_spending': financial_data.get('total_spending', 0),
                    'tier': 'Gold' if financial_data.get('transaction_count', 0) > 75 else 'Silver'
                }
            }
            perks_data = call_ai_agent('perks', 'generate-perks', perks_payload)
            if perks_data:
                insights['perks'] = perks_data
                logger.info("‚úÖ Personalized perks generated successfully")
        
        # STEP 3: Terms Agent - Credit Terms and Conditions
        if insights['ai_agents_status']['terms'] == 'healthy':
            logger.info("üìã Step 3: Terms Agent - Generating credit terms...")
            
            terms_payload = {
                'risk_data': insights.get('risk_assessment', {}),
                'spending_data': financial_data
            }
            terms_data = call_ai_agent('terms', 'terms', terms_payload)
            if terms_data:
                insights['terms'] = terms_data
                logger.info(f"‚úÖ Credit terms generated: {terms_data.get('terms', {}).get('apr_rate', 'N/A')}% APR")
        
        # STEP 4: Challenger Agent - Bank Profitability Optimization
        if insights['ai_agents_status'].get('challenger') == 'healthy' and insights.get('terms') and insights.get('risk_assessment'):
            logger.info("ü•ä Step 4: Challenger Agent - Optimizing for bank profitability...")
            
            challenger_payload = {
                'terms_proposal': insights['terms'].get('terms', {}),
                'risk_assessment': insights['risk_assessment'],
                'spending_data': {
                    'total_spending': financial_data.get('total_spending', 0),
                    'spending_categories': financial_data.get('spending_categories', {}),
                    'transaction_count': financial_data.get('transaction_count', 0)
                },
                'perks_data': insights.get('perks', {})
            }
            challenger_data = call_ai_agent('challenger', 'challenge-terms', challenger_payload)
            if challenger_data:
                insights['challenger_analysis'] = challenger_data
                logger.info(f"‚úÖ Challenger analysis completed: {challenger_data.get('decision', {}).get('action', 'N/A')}")
                
                # STEP 5: Arbiter Decision - Final Terms Optimization
                insights['final_decision'] = make_arbiter_decision(
                    insights['terms'], 
                    challenger_data,
                    insights['risk_assessment']
                )
                logger.info(f"‚öñÔ∏è Arbiter decision: {insights['final_decision'].get('arbiter_decision')}")
                
                # STEP 6: Policy Agent - Legal Document Generation
                if insights['final_decision'].get('arbiter_decision') in ['approve_counter_offer', 'approve_original', 'approve_original_with_monitoring', 'approve_alternative_offer']:
                    if insights['ai_agents_status'].get('policy') == 'healthy':
                        logger.info("üìú Step 6: Policy Agent - Generating legal documents...")
                        
                        policy_payload = {
                            'final_terms': insights['final_decision'].get('final_terms', {}),
                            'user_info': financial_data,
                            'arbiter_decision': insights['final_decision'],
                            'username': financial_data.get('username', 'testuser'),
                            'account_id': financial_data.get('account_id', 'N/A')
                        }
                        policy_data = call_ai_agent('policy', 'generate-policy-documents', policy_payload)
                        if policy_data:
                            insights['policy_documents'] = policy_data
                            logger.info("‚úÖ Policy documents generated successfully")
        
        logger.info("üéâ AI agent orchestration completed successfully")
        return insights
    
    def make_arbiter_decision(original_terms, challenger_analysis, risk_assessment):
        """
        Arbiter logic: 80% bank economics, 20% user value
        Prioritizes bank profitability while finding creative solutions
        """
        try:
            decision = challenger_analysis.get('decision', {})
            action = decision.get('action', 'approve_as_is')
            base_economics = challenger_analysis.get('base_economics', {})
            
            # Extract fee revenue from terms
            original_terms_data = original_terms.get('terms', {})
            annual_fee = original_terms_data.get('annual_fee', 0)
            late_fee = original_terms_data.get('late_fee', 0)
            
            if action == 'approve_as_is':
                # Validate original terms profitability
                original_roe = base_economics.get('roe', 0)
                original_profit = base_economics.get('profit_monthly', 0)
                
                # Calculate fee revenue impact
                monthly_fee_revenue = (annual_fee / 12) + (late_fee * 0.1)  # 10% late payment rate
                adjusted_profit = original_profit + monthly_fee_revenue
                adjusted_roe = (adjusted_profit * 12) / base_economics.get('capital_requirement', 1)
                
                if adjusted_roe >= 0.10:  # 10% minimum ROE threshold
                    return {
                        'arbiter_decision': 'approve_original',
                        'final_terms': original_terms_data,
                        'reason': f'Original terms profitable with fees (ROE: {adjusted_roe:.1%})',
                        'bank_economics_score': adjusted_roe * 100,
                        'user_value_score': 85,
                        'weighted_score': (adjusted_roe * 100 * 0.8) + (85 * 0.2),
                        'fee_revenue_monthly': monthly_fee_revenue,
                        'adjusted_profit_monthly': adjusted_profit
                    }
                else:
                    # Force counter-offer evaluation
                    action = 'counter_offer'
            
            if action == 'alternative_product':
                # Use the alternative product proposal
                alternative = decision.get('alternative_proposal', {})
                
                return {
                    'arbiter_decision': 'approve_alternative_offer',
                    'final_terms': alternative,
                    'reason': decision.get('reason', 'Alternative secured card offer with graduation program'),
                    'bank_economics_score': 75,
                    'user_value_score': 70,
                    'weighted_score': 75 * 0.8 + 70 * 0.2,
                    'strategy': 'Customer acquisition and development'
                }
            
            elif action == 'counter_offer':
                # Process counter-offer with enhanced profitability
                counter_terms = decision.get('counter_proposal', {})
                original_roe = base_economics.get('roe', 0)
                original_profit = base_economics.get('profit_monthly', 0)
                
                # Calculate economic improvements
                original_apr = original_terms_data.get('apr_rate', 18.99)
                counter_apr = counter_terms.get('apr_rate', original_apr)
                counter_annual_fee = counter_terms.get('annual_fee', annual_fee)
                
                # Economic impact calculations
                apr_improvement = counter_apr - original_apr
                revolving_balance = base_economics.get('revolving_balance', 0)
                additional_interest_revenue = (revolving_balance * (apr_improvement / 100)) / 12
                counter_monthly_fee_revenue = (counter_annual_fee / 12) + (late_fee * 0.1)
                
                # Final profitability calculation
                counter_profit = original_profit + additional_interest_revenue + counter_monthly_fee_revenue
                counter_roe = (counter_profit * 12) / base_economics.get('capital_requirement', 1)
                
                # User value impact assessment
                apr_penalty = apr_improvement * 8  # Penalty for APR increases
                limit_penalty = (original_terms_data.get('credit_limit', 15000) - counter_terms.get('credit_limit', 15000)) / 1000
                user_value_score = max(40, 85 - apr_penalty - limit_penalty)
                
                # Bank economics score
                bank_score = min(100, max(0, counter_roe * 100))
                weighted_score = (bank_score * 0.8) + (user_value_score * 0.2)
                
                # Decision logic prioritizing solutions over rejections
                if counter_roe >= 0.08:  # Reasonable profitability threshold
                    return {
                        'arbiter_decision': 'approve_counter_offer',
                        'final_terms': counter_terms,
                        'reason': f'Creative counter-offer achieves profitability (ROE: {counter_roe:.1%}) through innovative reward structure',
                        'bank_economics_score': bank_score,
                        'user_value_score': user_value_score,
                        'weighted_score': weighted_score,
                        'adjustments_made': counter_terms.get('adjustments', []),
                        'counter_roe': counter_roe,
                        'counter_profit_monthly': counter_profit,
                        'fee_revenue_monthly': counter_monthly_fee_revenue
                    }
                elif original_roe >= 0.03:  # Marginally acceptable
                    return {
                        'arbiter_decision': 'approve_original_with_monitoring',
                        'final_terms': original_terms_data,
                        'reason': f'Approved with enhanced monitoring (ROE: {original_roe:.1%}) - customer shows growth potential',
                        'bank_economics_score': original_roe * 100,
                        'user_value_score': user_value_score,
                        'weighted_score': (original_roe * 100 * 0.8) + (user_value_score * 0.2),
                        'monitoring_conditions': [
                            'Monthly spending review for credit limit increases',
                            'Quarterly profitability assessment',
                            'Automatic upgrade to premium rewards after 12 months'
                        ]
                    }
                else:
                    # Generate alternative starter card offer
                    alternative_offer = {
                        'card_type': 'Starter Card',
                        'apr_rate': min(24.99, counter_apr + 3),
                        'credit_limit': max(1000, counter_terms.get('credit_limit', 15000) // 2),
                        'annual_fee': 75,
                        'rewards': {
                            'base_rate': 0.5,
                            'bonus_category': 'Groceries - 2% up to $300/month',
                            'sign_up_bonus': '$100 after $500 spend in 3 months'
                        },
                        'graduation_program': {
                            'timeline': '12 months of on-time payments',
                            'upgrade_to': 'Premium rewards card with better terms',
                            'benefits': 'Credit limit increase and APR reduction'
                        }
                    }
                    
                    return {
                        'arbiter_decision': 'approve_alternative_offer',
                        'final_terms': alternative_offer,
                        'reason': 'Alternative starter card offer with graduation program - builds customer relationship while ensuring profitability',
                        'bank_economics_score': 75,
                        'user_value_score': 70,
                        'weighted_score': 75 * 0.8 + 70 * 0.2,
                        'strategy': 'Customer acquisition and development'
                    }
            
            # Fallback rejection
            return {
                'arbiter_decision': 'reject_application',
                'final_terms': None,
                'reason': decision.get('reason', 'Application does not meet risk criteria'),
                'bank_economics_score': 0,
                'user_value_score': 0,
                'weighted_score': 0
            }
                
        except Exception as e:
            logger.error(f"‚ùå Error in arbiter decision: {e}")
            return {
                'arbiter_decision': 'reject_application',
                'final_terms': None,
                'reason': f'Arbiter error - rejecting for safety: {str(e)}'
            }
    
    # ==========================================================================
    # FALLBACK DATA
    # ==========================================================================
    
    def get_fallback_data(username):
        """
        Provide fallback data when Bank of Anthos services are unavailable
        """
        return {
            'username': username,
            'account_id': DEMO_USERS[username]['account_id'],
            'current_balance': 1250.50,
            'transaction_count': 95,
            'total_spending': 2840.75,
            'spending_categories': {
                'Groceries': {'total': 425.50, 'count': 12, 'amount': 45.50},
                'Coffee & Cafes': {'total': 89.25, 'count': 18, 'amount': 5.75},
                'Gas & Fuel': {'total': 340.80, 'count': 8, 'amount': 42.50},
                'Online Retail': {'total': 675.20, 'count': 15, 'amount': 67.50},
                'Restaurants': {'total': 245.75, 'count': 9, 'amount': 28.50},
                'Electronics': {'total': 899.99, 'count': 2, 'amount': 449.99},
                'Utilities': {'total': 164.26, 'count': 2, 'amount': 82.13}
            },
            'credit_score': 720,
            'recommendation': '‚úÖ Very Good - Qualify for Most Credit Cards',
            'ai_assessment': {
                'credit_score': 720,
                'recommendation': '‚úÖ Very Good - Qualify for Most Credit Cards',
                'ai_generated': True,
                'analysis_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'note': 'Based on cached transaction analysis'
            }
        }
    
    # ==========================================================================
    # API ENDPOINTS
    # ==========================================================================
    
    @app.route('/health')
    def health():
        """Health check endpoint"""
        return jsonify({
            'status': 'healthy', 
            'service': 'backend-service', 
            'cache_size': len(cache),
            'ai_agents': list(AI_AGENTS.keys()),
            'version': 'v1.0.0'
        })
    
    @app.route('/api/real-preapproval')
    def get_preapproval():
        """
        Main API endpoint for AI-powered credit pre-approval
        """
        username = request.args.get('username', 'testuser')
        logger.info(f"üöÄ Starting pre-approval process for {username}")
        
        try:
            # Gather financial data from Bank of Anthos services
            balance = get_balance(username)
            transactions = get_transactions(username)
            spending_categories = analyze_spending(transactions, username)
            
            # Process if we have valid data
            if transactions or balance > 0:
                # Calculate credit score based on financial behavior
                score = 580  # Base score
                
                # Transaction volume bonus
                if len(transactions) > 100:
                    score += 50
                elif len(transactions) > 50:
                    score += 30
                elif len(transactions) > 20:
                    score += 20
                    
                # Balance stability bonus
                if balance > 1000:
                    score += 40
                elif balance > 100:
                    score += 20
                    
                # Spending diversity bonus
                if len(spending_categories) > 5:
                    score += 30
                elif len(spending_categories) > 0:
                    score += 20
                    
                score = min(850, score)  # Cap at excellent credit
                
                # Generate recommendation
                recommendation = (
                    "üåü Excellent - Premium Credit Cards with Best Rewards" if score >= 750 else
                    "‚úÖ Very Good - Qualify for Most Credit Cards" if score >= 700 else
                    "üëç Good - Standard Credit Cards Available" if score >= 650 else
                    "‚ö†Ô∏è Fair - Consider Secured Credit Cards" if score >= 600 else
                    "‚ö†Ô∏è Consider Secured Credit Card"
                )
                
                # Prepare data for AI agents
                financial_data = {
                    'username': username,
                    'account_id': DEMO_USERS[username]['account_id'],
                    'current_balance': balance,
                    'transaction_count': len(transactions),
                    'total_spending': sum(cat.get('total', 0) for cat in spending_categories.values()),
                    'spending_categories': spending_categories
                }
                
                # Get AI insights through agent orchestration
                ai_insights = get_ai_insights(financial_data)
                
                # Build comprehensive response
                response = {
                    'username': username,
                    'account_id': DEMO_USERS[username]['account_id'],
                    'current_balance': balance,
                    'transaction_count': len(transactions),
                    'total_spending': sum(cat.get('total', 0) for cat in spending_categories.values()),
                    'spending_categories': spending_categories,
                    'credit_score': score,
                    'recommendation': recommendation,
                    'ai_assessment': {
                        'credit_score': score,
                        'recommendation': recommendation,
                        'ai_generated': True,
                        'analysis_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    },
                    'ai_insights': ai_insights
                }
                
                logger.info(f"‚úÖ Generated comprehensive response for {username}: {len(spending_categories)} categories, {len(transactions)} transactions")
                return jsonify(response)
            else:
                # Use fallback data if services unavailable
                logger.warning(f"‚ö†Ô∏è Services unavailable, using fallback data for {username}")
                return jsonify(get_fallback_data(username))
                
        except Exception as e:
            logger.error(f"‚ùå Error generating response: {e}")
            logger.info(f"üîÑ Using fallback data due to error for {username}")
            return jsonify(get_fallback_data(username))
    
    @app.route('/api/cache-status')
    def cache_status():
        """Cache status and management endpoint"""
        return jsonify({
            'cache_entries': len(cache),
            'cache_keys': list(cache.keys()) if cache else [],
            'ttl_seconds': CACHE_TTL
        })
    
    @app.route('/api/clear-cache')
    def clear_cache():
        """Clear all cached data"""
        global cache
        cache.clear()
        return jsonify({'message': 'Cache cleared', 'cache_size': len(cache)})
    
    @app.route('/')
    def home():
        """API information endpoint"""
        return jsonify({
            'message': 'AI Credit Pre-Approval Backend Service',
            'version': 'v1.0.0',
            'endpoints': [
                '/api/real-preapproval?username=testuser',
                '/api/cache-status',
                '/api/clear-cache',
                '/health'
            ],
            'features': [
                'AI Agent Orchestration',
                'Intelligent Retry Logic', 
                'Response Caching', 
                'Graceful Degradation',
                'Bank Profitability Optimization',
                'Comprehensive Credit Scoring'
            ],
            'ai_agents': list(AI_AGENTS.keys())
        })
    
    # ==========================================================================
    # APPLICATION STARTUP
    # ==========================================================================
    
    if __name__ == '__main__':
        port = int(os.environ.get('PORT', 8080))
        logger.info(f"üöÄ Starting AI Credit Pre-Approval Backend Service on port {port}")
        logger.info(f"ü§ñ AI Agents configured: {', '.join(AI_AGENTS.keys())}")
        logger.info(f"üè¶ Bank of Anthos services: {', '.join(SERVICES.keys())}")
        app.run(host='0.0.0.0', port=port, debug=False)

---
# =============================================================================
# KUBERNETES DEPLOYMENT CONFIGURATION
# =============================================================================

apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-service
  namespace: default
  labels:
    app: backend-service
    component: ai-orchestration-backend
    version: v1.0.0
spec:
  replicas: 2  # High availability with 2 replicas
  selector:
    matchLabels:
      app: backend-service
  template:
    metadata:
      labels:
        app: backend-service
        component: ai-orchestration-backend
        version: v1.0.0
    spec:
      containers:
      - name: backend-service
        image: python:3.12-slim
        workingDir: /app
        command: ["/bin/bash", "-c", "pip install flask flask-cors requests urllib3 psycopg2-binary && python app.py"]
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: PORT
          value: "8080"
        volumeMounts:
        - name: code
          mountPath: /app
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "250m"
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 30
      volumes:
      - name: code
        configMap:
          name: backend-service-code

---
# =============================================================================
# KUBERNETES SERVICE CONFIGURATION
# =============================================================================

apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: default
  labels:
    app: backend-service
    component: ai-orchestration-backend
    version: v1.0.0
spec:
  selector:
    app: backend-service
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
  type: LoadBalancer
  loadBalancerSourceRanges: []  # Allow access from all IPs
