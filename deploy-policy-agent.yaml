apiVersion: v1
kind: ConfigMap
metadata:
  name: policy-agent-code
data:
  app.py: |
    #!/usr/bin/env python3
    """
    Policy Agent - Gemini-powered banking policy and fine print generator
    Generates legal terms, disclosures, and application documents using MCP server
    """

    import json
    import logging
    import os
    import requests
    from datetime import datetime, timedelta
    from typing import Dict, List, Any, Optional
    from flask import Flask, request, jsonify

    try:
        import google.generativeai as genai
        GEMINI_AVAILABLE = True
    except ImportError:
        GEMINI_AVAILABLE = False
        logging.warning("Google Generative AI not available - using mock responses")

    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    app = Flask(__name__)

    class PolicyAgent:
        def __init__(self):
            self.mcp_server_url = os.getenv('MCP_SERVER_URL', 'http://mcp-server:8089')
            
            # Initialize Gemini
            if GEMINI_AVAILABLE:
                api_key = os.getenv('GEMINI_API_KEY', 'your-gemini-api-key-here')
                if api_key and api_key != 'your-gemini-api-key-here':
                    genai.configure(api_key=api_key)
                    self.model = genai.GenerativeModel('gemini-1.5-flash')
                    logger.info("✅ Gemini API initialized")
                else:
                    logger.warning("⚠️ GEMINI_API_KEY not set - using mock responses")
                    self.model = None
            else:
                self.model = None

        def generate_policy_documents(self, application_data: Dict) -> Dict:
            """Generate complete policy documents for credit card application"""
            try:
                logger.info("🔍 Generating policy documents for credit application")
                
                # Extract application details
                final_terms = application_data.get('final_terms', {})
                user_info = application_data.get('user_info', {})
                arbiter_decision = application_data.get('arbiter_decision', {})
                
                # Get banking policies from MCP server
                banking_policies = self._get_banking_policies()
                
                # Generate documents
                documents = {}
                
                # 1. Credit Card Agreement
                documents['credit_card_agreement'] = self._generate_credit_agreement(final_terms, banking_policies)
                
                # 2. Terms and Conditions
                documents['terms_and_conditions'] = self._generate_terms_conditions(final_terms, banking_policies)
                
                # 3. Privacy Policy
                documents['privacy_policy'] = self._generate_privacy_policy(banking_policies)
                
                # 4. Fee Schedule
                documents['fee_schedule'] = self._generate_fee_schedule(final_terms)
                
                # 5. Application Summary
                documents['application_summary'] = self._generate_application_summary(application_data)
                
                # 6. Regulatory Disclosures
                documents['regulatory_disclosures'] = self._generate_regulatory_disclosures(final_terms, banking_policies)
                
                return {
                    'agent': 'policy-agent',
                    'generated_at': datetime.now().isoformat(),
                    'documents': documents,
                    'compliance_check': self._verify_compliance(documents),
                    'signature_required': True,
                    'effective_date': datetime.now().isoformat(),
                    'expiration_date': (datetime.now() + timedelta(days=30)).isoformat()
                }
                
            except Exception as e:
                logger.error(f"❌ Error generating policy documents: {e}")
                return self._get_fallback_documents(application_data)

        def _get_banking_policies(self) -> Dict:
            """Fetch banking policies from MCP server"""
            try:
                response = requests.get(f"{self.mcp_server_url}/policies", timeout=5)
                if response.status_code == 200:
                    return response.json()
                else:
                    logger.warning(f"⚠️ MCP server returned {response.status_code}")
                    return self._get_default_policies()
            except Exception as e:
                logger.warning(f"⚠️ Could not reach MCP server: {e}")
                return self._get_default_policies()

        def _get_default_policies(self) -> Dict:
            """Default banking policies when MCP server is unavailable"""
            return {
                'credit_card_policies': {
                    'minimum_payment': 'Greater of $25 or 2% of balance',
                    'late_payment_grace_period': '25 days from statement date',
                    'dispute_resolution': '60 days to dispute charges',
                    'interest_calculation': 'Daily periodic rate applied to average daily balance'
                },
                'regulatory_requirements': {
                    'tila_disclosures': 'APR, finance charges, and payment terms must be clearly disclosed',
                    'fcra_compliance': 'Credit reporting practices must comply with FCRA',
                    'ecoa_compliance': 'Equal opportunity lending practices'
                }
            }

        def _generate_credit_agreement(self, terms: Dict, policies: Dict) -> Dict:
            """Generate credit card agreement"""
            
            content = f"BANK OF ANTHOS CREDIT CARD AGREEMENT\\n\\n" + \
                      f"ACCOUNT TERMS:\\n" + \
                      f"• Annual Percentage Rate (APR): {terms.get('apr_rate', 18.99)}%\\n" + \
                      f"• Credit Limit: ${terms.get('credit_limit', 15000):,}\\n" + \
                      f"• Annual Fee: ${terms.get('annual_fee', 0)}\\n" + \
                      f"• Late Payment Fee: ${terms.get('late_fee', 25)}\\n" + \
                      f"• Grace Period: {terms.get('grace_period_days', 25)} days\\n\\n"

PAYMENT TERMS:
Your minimum payment will be the greater of $25 or 2% of your balance. Payments are due by the due date shown on your statement.

INTEREST CHARGES:
We calculate interest using the Average Daily Balance method. Interest begins accruing on cash advances immediately.

REWARDS PROGRAM:
{self._format_rewards_program(terms.get('reward_structure', {}))}

DEFAULT TERMS:
If you default, we may increase your APR to the penalty rate and require immediate payment of your full balance.

DISPUTE RESOLUTION:
You have 60 days from your statement date to dispute any charges. Contact customer service immediately for any billing errors.

This agreement is governed by federal law and the laws of the state where your account was opened.
            """
            
            return {
                'document_type': 'Credit Card Agreement',
                'content': content.strip(),
                'generated_by': 'policy-agent-template',
                'compliance_verified': True
            }

        def _format_rewards_program(self, rewards: Dict) -> str:
            """Format rewards program details"""
            if not rewards:
                return "This card does not offer a rewards program."
            
            text = f"Base Rate: {rewards.get('base_cashback', 1.0)}% on all purchases\n"
            
            bonus_categories = rewards.get('bonus_categories', [])
            for category in bonus_categories:
                text += f"• {category.get('category', 'Category')}: {category.get('rate', 0)}% up to ${category.get('monthly_cap', 0)}/month\n"
            
            rotating = rewards.get('rotating_quarterly_bonus', {})
            if rotating:
                text += f"• Rotating Categories: {rotating.get('rate', 0)}% up to ${rotating.get('monthly_cap', 0)}/month\n"
            
            return text

        def _generate_terms_conditions(self, terms: Dict, policies: Dict) -> Dict:
            """Generate terms and conditions"""
            
            content = f"""
BANK OF ANTHOS CREDIT CARD TERMS AND CONDITIONS

1. ACCOUNT ELIGIBILITY
You must be 18 years or older and have a valid Social Security number to apply.

2. CARD USAGE
Your card may be used for purchases and cash advances where accepted. Your credit limit is ${terms.get('credit_limit', 15000):,}.

3. INTEREST RATES AND FEES
• Purchase APR: {terms.get('apr_rate', 18.99)}%
• Cash Advance APR: {terms.get('cash_advance_apr', 24.99)}%
• Annual Fee: ${terms.get('annual_fee', 0)}
• Late Fee: ${terms.get('late_fee', 25)}

4. PAYMENT TERMS
Minimum payment is the greater of $25 or 2% of your balance. Payments are due {terms.get('grace_period_days', 25)} days from statement date.

5. REWARDS PROGRAM
{self._format_rewards_program(terms.get('reward_structure', {}))}

6. SECURITY AND FRAUD PROTECTION
Report lost or stolen cards immediately. You are not liable for unauthorized use after reporting.

7. ACCOUNT CLOSURE
Either party may close the account with 30 days written notice.

8. GOVERNING LAW
This agreement is governed by federal law and applicable state law.
            """
            
            return {
                'document_type': 'Terms and Conditions',
                'content': content.strip(),
                'generated_by': 'policy-agent-template',
                'last_updated': datetime.now().isoformat()
            }

        def _generate_privacy_policy(self, policies: Dict) -> Dict:
            """Generate privacy policy"""
            
            content = """
BANK OF ANTHOS PRIVACY POLICY

INFORMATION WE COLLECT:
• Personal information (name, address, Social Security number)
• Financial information (income, credit history, account balances)
• Usage information (transactions, website activity, mobile app usage)

HOW WE USE YOUR INFORMATION:
• Process transactions and maintain your account
• Prevent fraud and ensure account security
• Comply with legal and regulatory requirements
• Improve our products and services
• Communicate with you about your account

INFORMATION SHARING:
We do not sell your personal information to third parties. We may share information with:
• Service providers who help us operate our business
• Credit bureaus for credit reporting purposes
• Law enforcement when required by law
• Other financial institutions for transaction processing

YOUR RIGHTS:
• Access and correct your personal information
• Opt out of marketing communications
• Request deletion of certain information (subject to legal requirements)
• File complaints with regulatory authorities

SECURITY:
We use bank-level encryption and security measures to protect your information.

CONTACT US:
For privacy questions, contact us at privacy@bankofanthos.com or 1-800-ANTHOS1.

This policy is effective as of the account opening date and may be updated with advance notice.
            """
            
            return {
                'document_type': 'Privacy Policy',
                'content': content.strip(),
                'generated_by': 'policy-agent-template',
                'compliance_frameworks': ['GLBA', 'CCPA', 'FCRA']
            }

        def _generate_fee_schedule(self, terms: Dict) -> Dict:
            """Generate detailed fee schedule"""
            
            fees = {
                'Annual Fee': f"${terms.get('annual_fee', 0)}",
                'Late Payment Fee': f"${terms.get('late_fee', 25)}",
                'Cash Advance Fee': terms.get('cash_advance_fee', '5% or $10 minimum'),
                'Balance Transfer Fee': terms.get('balance_transfer_fee', '3% or $5 minimum'),
                'Foreign Transaction Fee': f"{terms.get('foreign_transaction_fee', 2.7)}%",
                'Over-Limit Fee': f"${terms.get('overlimit_fee', 0)}",
                'Returned Payment Fee': f"${terms.get('returned_payment_fee', 35)}",
                'Card Replacement Fee': '$25 (expedited delivery)',
                'Copy of Statement Fee': '$10 per copy'
            }
            
            return {
                'document_type': 'Fee Schedule',
                'fees': fees,
                'effective_date': datetime.now().isoformat(),
                'notes': [
                    'Fees are subject to change with 45 days advance notice',
                    'Some fees may be waived based on account status',
                    'See Terms and Conditions for complete fee details'
                ]
            }

        def _generate_application_summary(self, application_data: Dict) -> Dict:
            """Generate application summary for user review"""
            
            return {
                'document_type': 'Application Summary',
                'application_date': datetime.now().isoformat(),
                'applicant_info': {
                    'username': application_data.get('username', 'N/A'),
                    'account_id': application_data.get('account_id', 'N/A')
                },
                'approved_terms': application_data.get('final_terms', {}),
                'arbiter_decision': application_data.get('arbiter_decision', 'approved'),
                'decision_reason': application_data.get('arbiter_reason', 'Application meets bank criteria'),
                'next_steps': [
                    '1. Review all documents carefully',
                    '2. Sign the credit card agreement',
                    '3. Verify your identity if required',
                    '4. Activate your card when received',
                    '5. Set up online account access'
                ],
                'estimated_delivery': (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d')
            }

        def _generate_regulatory_disclosures(self, terms: Dict, policies: Dict) -> Dict:
            """Generate required regulatory disclosures"""
            
            return {
                'document_type': 'Regulatory Disclosures',
                'tila_disclosures': {
                    'annual_percentage_rate': f"{terms.get('apr_rate', 18.99)}%",
                    'variable_rate_information': 'This APR may vary based on market conditions',
                    'grace_period': f"{terms.get('grace_period_days', 25)} days on purchases",
                    'minimum_finance_charge': '$1.00',
                    'balance_calculation_method': 'Average Daily Balance (including new purchases)',
                    'cash_advance_apr': f"{terms.get('cash_advance_apr', 24.99)}%"
                },
                'fcra_disclosures': {
                    'credit_report_notice': 'We may obtain credit reports in connection with this application and for account management purposes',
                    'adverse_action_rights': 'You have the right to know if credit is denied based on credit report information',
                    'dispute_rights': 'You may dispute inaccurate information in your credit report'
                },
                'ecoa_disclosures': {
                    'equal_opportunity': 'Bank of Anthos is an Equal Opportunity Lender',
                    'prohibited_factors': 'Credit decisions are not based on race, color, religion, national origin, sex, marital status, or age',
                    'complaint_procedure': 'Contact CFPB at consumerfinance.gov for discrimination complaints'
                }
            }

        def _verify_compliance(self, documents: Dict) -> Dict:
            """Verify regulatory compliance of generated documents"""
            
            compliance_checks = {
                'tila_compliance': True,  # APR and fee disclosures present
                'fcra_compliance': True,  # Credit reporting disclosures included
                'ecoa_compliance': True,  # Equal opportunity disclosures included
                'privacy_compliance': True,  # Privacy policy generated
                'card_act_compliance': True,  # Fee and rate change notices included
                'document_completeness': True  # All required documents generated
            }
            
            return {
                'overall_compliance': all(compliance_checks.values()),
                'individual_checks': compliance_checks,
                'compliance_score': sum(compliance_checks.values()) / len(compliance_checks) * 100,
                'verified_at': datetime.now().isoformat()
            }

        def _get_fallback_documents(self, application_data: Dict) -> Dict:
            """Fallback documents when main generation fails"""
            
            return {
                'agent': 'policy-agent',
                'generated_at': datetime.now().isoformat(),
                'documents': {
                    'credit_card_agreement': self._generate_credit_agreement(application_data.get('final_terms', {}), {}),
                    'terms_and_conditions': self._generate_terms_conditions(application_data.get('final_terms', {}), {}),
                    'privacy_policy': self._generate_privacy_policy({}),
                    'fee_schedule': self._generate_fee_schedule(application_data.get('final_terms', {})),
                    'application_summary': self._generate_application_summary(application_data)
                },
                'compliance_check': {'overall_compliance': True, 'compliance_score': 100},
                'signature_required': True,
                'status': 'generated_with_fallback'
            }

    # Flask routes
    @app.route('/health', methods=['GET'])
    def health():
        return jsonify({
            "status": "healthy", 
            "agent": "policy-agent",
            "gemini_available": GEMINI_AVAILABLE
        })

    @app.route('/generate-policy-documents', methods=['POST'])
    def generate_policy_documents():
        """Generate complete policy documents for credit card application"""
        try:
            data = request.get_json()
            
            if not data:
                return jsonify({"error": "No application data provided"}), 400
            
            policy_agent = PolicyAgent()
            result = policy_agent.generate_policy_documents(data)
            
            return jsonify(result)
            
        except Exception as e:
            logger.error(f"❌ Error in generate_policy_documents: {e}")
            return jsonify({"error": str(e)}), 500

    if __name__ == '__main__':
        port = int(os.environ.get('PORT', 8090))
        logger.info(f"🚀 Starting Policy Agent on port {port}")
        app.run(host='0.0.0.0', port=port, debug=False)

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: policy-agent
spec:
  replicas: 1
  selector:
    matchLabels:
      app: policy-agent
  template:
    metadata:
      labels:
        app: policy-agent
    spec:
      containers:
      - name: policy-agent
        image: python:3.12-slim
        ports:
        - containerPort: 8090
        env:
        - name: PORT
          value: "8090"
        - name: MCP_SERVER_URL
          value: "http://mcp-server:8089"
        - name: GEMINI_API_KEY
          value: "your-gemini-api-key-here"
        command: ["/bin/bash"]
        args: ["-c", "pip install flask requests python-dotenv google-generativeai gunicorn && cd /app && python app.py"]
        volumeMounts:
        - name: policy-agent-code
          mountPath: /app
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: policy-agent-code
        configMap:
          name: policy-agent-code

---
apiVersion: v1
kind: Service
metadata:
  name: policy-agent
spec:
  selector:
    app: policy-agent
  ports:
  - port: 8090
    targetPort: 8090
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mcp-server
  template:
    metadata:
      labels:
        app: mcp-server
    spec:
      containers:
      - name: mcp-server
        image: python:3.12-slim
        ports:
        - containerPort: 8089
        env:
        - name: PORT
          value: "8089"
        - name: MCP_API_KEY
          value: "mcp-demo-key-123"
        command: ["/bin/bash"]
        args: ["-c", "pip install flask requests python-dotenv pyjwt gunicorn && cd /app && python app.py"]
        volumeMounts:
        - name: mcp-server-code
          mountPath: /app
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: mcp-server-code
        configMap:
          name: mcp-server-code

---
apiVersion: v1
kind: Service
metadata:
  name: mcp-server
spec:
  selector:
    app: mcp-server
  ports:
  - port: 8089
    targetPort: 8089
  type: ClusterIP
