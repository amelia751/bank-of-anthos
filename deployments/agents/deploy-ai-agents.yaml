# =============================================================================
# AI AGENTS DEPLOYMENT - COMPREHENSIVE CREDIT ANALYSIS SYSTEM
# =============================================================================
# 
# This deployment creates all AI agents required for the comprehensive credit
# pre-approval system, including Risk Assessment, Terms Generation, Personalized
# Perks, Bank Profitability Optimization, and Legal Document Generation.
#
# AI AGENTS INCLUDED:
# - Risk Agent: Credit scoring and approval decisions with Gemini reasoning
# - Terms Agent: APR calculation and credit limit determination
# - Perks Agent: Personalized cashback rewards based on spending patterns
# - Challenger Agent: Bank profitability optimization and counter-offers
# - Policy Agent: Legal document generation with regulatory compliance
# - MCP Server: Banking policies and regulatory requirements database
#
# FEATURES:
# - Advanced AI reasoning with Google Gemini integration
# - Real-time spending analysis and pattern recognition
# - Multi-objective optimization (user value vs bank profitability)
# - Comprehensive legal document generation
# - Regulatory compliance checking
# - Agent health monitoring and status reporting
#
# DEPLOYMENT:
# kubectl apply -f deployments/agents/deploy-ai-agents.yaml
#
# =============================================================================

# =============================================================================
# PERKS AGENT - PERSONALIZED REWARDS SYSTEM
# =============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: perks-agent-code
  namespace: default
  labels:
    app: perks-agent
    component: ai-rewards-engine
    version: v1.0.0
data:
  app.py: |
    #!/usr/bin/env python3
    """
    Perks Agent - Personalized Credit Card Rewards System
    ==================================================
    
    Analyzes user spending patterns to generate personalized cashback rewards
    and credit card perks tailored to individual financial behavior.
    """
    
    import os
    import json
    import logging
    from flask import Flask, request, jsonify
    from datetime import datetime
    import random
    
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    app = Flask(__name__)
    
    @app.route('/health')
    def health():
        return jsonify({'status': 'healthy', 'agent': 'perks'})
    
    @app.route('/generate-perks', methods=['POST'])
    def generate_perks():
        try:
            data = request.json
            user_data = data.get('user_data', {})
            spending_analysis = data.get('spending_analysis', {})
            
            # Extract spending patterns
            top_categories = spending_analysis.get('top_categories', [])
            total_spending = spending_analysis.get('total_spending', 0)
            tier = spending_analysis.get('tier', 'Silver')
            
            # Generate personalized perks based on spending
            perks = []
            card_name = f"Bank of Anthos {tier} Rewards Card"
            
            # Base cashback
            base_rate = 1.5 if tier == 'Gold' else 1.0
            perks.append(f"{base_rate}% cashback on all purchases")
            
            # Category-specific rewards
            for category_data in top_categories[:3]:
                category = category_data.get('category', '')
                if category:
                    rate = 3.0 if tier == 'Gold' else 2.5
                    perks.append(f"{rate}% cashback on {category}")
            
            # Tier-specific benefits
            if tier == 'Gold':
                perks.extend([
                    "No foreign transaction fees",
                    "Priority customer service",
                    "Travel insurance coverage",
                    "Extended warranty protection"
                ])
            else:
                perks.extend([
                    "Mobile payment bonus",
                    "Online purchase protection",
                    "Fraud monitoring"
                ])
            
            # Calculate estimated annual value
            estimated_value = len(perks) * 50
            
            response = {
                'perks': {
                    'card_name': card_name,
                    'tier': tier,
                    'perks': perks,
                    'estimated_annual_value': estimated_value,
                    'cashback_structure': {
                        'base_rate': base_rate,
                        'bonus_categories': [
                            {'category': cat.get('category', ''), 'rate': 3.0 if tier == 'Gold' else 2.5}
                            for cat in top_categories[:3]
                        ]
                    }
                },
                'analysis_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            return jsonify(response)
            
        except Exception as e:
            return jsonify({'error': 'Failed to generate perks'}), 500
    
    if __name__ == '__main__':
        port = int(os.environ.get('PORT', 8085))
        app.run(host='0.0.0.0', port=port, debug=False)

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: perks-agent
  namespace: default
  labels:
    app: perks-agent
    component: ai-rewards-engine
    version: v1.0.0
spec:
  replicas: 1
  selector:
    matchLabels:
      app: perks-agent
  template:
    metadata:
      labels:
        app: perks-agent
        component: ai-rewards-engine
        version: v1.0.0
    spec:
      containers:
      - name: perks-agent
        image: python:3.12-slim
        workingDir: /app
        command: ["/bin/bash", "-c", "pip install flask && python app.py"]
        ports:
        - containerPort: 8085
          name: http
        env:
        - name: PORT
          value: "8085"
        volumeMounts:
        - name: code
          mountPath: /app
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "100m"
      volumes:
      - name: code
        configMap:
          name: perks-agent-code

---
apiVersion: v1
kind: Service
metadata:
  name: perks-agent-real
  namespace: default
  labels:
    app: perks-agent
    component: ai-rewards-engine
    version: v1.0.0
spec:
  selector:
    app: perks-agent
  ports:
  - port: 8085
    targetPort: 8085
    protocol: TCP
    name: http
  type: ClusterIP

---
# =============================================================================
# RISK AGENT - ENHANCED CREDIT SCORING WITH GEMINI
# =============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: enhanced-risk-agent-code
  namespace: default
  labels:
    app: enhanced-risk-agent
    component: ai-credit-scoring
    version: v1.0.0
data:
  app.py: |
    #!/usr/bin/env python3
    """
    Enhanced Risk Agent - AI-Powered Credit Assessment
    ===============================================
    
    Advanced credit risk assessment using AI reasoning with Google Gemini
    for comprehensive approval decisions and detailed risk analysis.
    """
    
    import os
    import json
    import logging
    from flask import Flask, request, jsonify
    from datetime import datetime
    import random
    
    # Gemini integration (if available)
    try:
        import google.generativeai as genai
        GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
        if GEMINI_API_KEY:
            genai.configure(api_key=GEMINI_API_KEY)
            model = genai.GenerativeModel('gemini-pro')
            GEMINI_AVAILABLE = True
        else:
            GEMINI_AVAILABLE = False
    except ImportError:
        GEMINI_AVAILABLE = False
    
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    app = Flask(__name__)
    
    def calculate_risk_score(user_id, months=6):
        """Calculate comprehensive risk score"""
        # Simulate risk calculation based on user behavior
        base_score = random.randint(650, 780)
        
        risk_factors = {
            'income_stability': random.uniform(0.6, 0.9),
            'expense_ratio': random.uniform(0.3, 0.7),
            'payment_reliability': random.uniform(0.8, 1.0),
            'debt_utilization': random.uniform(0.1, 0.4)
        }
        
        # Determine tier based on score
        if base_score >= 750:
            tier = 'Gold'
        elif base_score >= 700:
            tier = 'Silver'
        else:
            tier = 'Standard'
        
        return {
            'score': base_score,
            'tier': tier,
            'risk_factors': risk_factors,
            'analysis_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
    
    def make_approval_decision(risk_data, spending_data):
        """Make approval decision with reasoning"""
        score = risk_data.get('score', 650)
        risk_factors = risk_data.get('risk_factors', {})
        
        # Decision logic
        if score >= 720 and risk_factors.get('payment_reliability', 0) > 0.8:
            decision = 'APPROVED'
            risk_level = 'LOW'
        elif score >= 650 and risk_factors.get('payment_reliability', 0) > 0.7:
            decision = 'CONDITIONAL_APPROVAL'
            risk_level = 'MEDIUM'
        else:
            decision = 'REJECTED'
            risk_level = 'HIGH'
        
        return {
            'decision': decision,
            'risk_level': risk_level,
            'reasoning': _generate_reasoning(decision, risk_data, spending_data),
            'conditions': _get_approval_conditions(decision, risk_data)
        }
    
    def _generate_reasoning(decision, risk_data, spending_data):
        """Generate detailed reasoning for the decision"""
        if GEMINI_AVAILABLE:
            try:
                prompt = f"""
                As a credit risk analyst, provide a detailed explanation for this credit decision:
                
                Decision: {decision}
                Credit Score: {risk_data.get('score', 'N/A')}
                Risk Factors: {json.dumps(risk_data.get('risk_factors', {}), indent=2)}
                Spending Data: {json.dumps(spending_data, indent=2)}
                
                Provide a professional, detailed explanation in 2-3 sentences focusing on:
                1. Key factors that influenced the decision
                2. Risk assessment rationale
                3. Customer's financial profile strengths/weaknesses
                
                Keep it concise but comprehensive.
                """
                
                response = model.generate_content(prompt)
                return response.text.strip()
            except Exception as e:
        
        # Fallback reasoning
        score = risk_data.get('score', 650)
        payment_reliability = risk_data.get('risk_factors', {}).get('payment_reliability', 0.7)
        
        if decision == 'APPROVED':
            return f"Approved based on excellent credit score ({score}) and strong payment history ({payment_reliability:.1%} reliability). Customer demonstrates consistent financial responsibility with diversified spending patterns."
        elif decision == 'CONDITIONAL_APPROVAL':
            return f"Conditional approval granted with credit score of {score} and good payment reliability ({payment_reliability:.1%}). Some monitoring recommended due to moderate risk factors."
        else:
            return f"Application declined due to credit score ({score}) below threshold and risk factors indicating potential repayment challenges. Consider secured credit options."
    
    def _get_approval_conditions(decision, risk_data):
        """Get conditions for conditional approvals"""
        if decision == 'CONDITIONAL_APPROVAL':
            return [
                "Lower initial credit limit",
                "Monthly payment monitoring",
                "Quarterly risk reassessment",
                "Automatic review after 6 months"
            ]
        return []
    
    @app.route('/health')
    def health():
        return jsonify({
            'status': 'healthy', 
            'agent': 'enhanced-risk',
            'gemini_available': GEMINI_AVAILABLE
        })
    
    @app.route('/assess', methods=['POST'])
    def assess_risk():
        """Basic risk assessment endpoint"""
        try:
            data = request.json
            user_id = data.get('user_id', 'testuser')
            months = data.get('months', 6)
            
            risk_data = calculate_risk_score(user_id, months)
            
            return jsonify(risk_data)
            
        except Exception as e:
            return jsonify({'error': 'Risk assessment failed'}), 500
    
    @app.route('/approve', methods=['POST'])
    def approve_application():
        """Approval decision endpoint with Gemini reasoning"""
        try:
            data = request.json
            user_id = data.get('user_id', 'testuser')
            spending_data = data.get('spending_data', {})
            
            # Get risk assessment
            risk_data = calculate_risk_score(user_id)
            
            # Make approval decision
            approval_data = make_approval_decision(risk_data, spending_data)
            
            # Combine results
            response = {
                **approval_data,
                'risk_assessment': risk_data,
                'analysis_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            return jsonify(response)
            
        except Exception as e:
            return jsonify({'error': 'Approval decision failed'}), 500
    
    if __name__ == '__main__':
        port = int(os.environ.get('PORT', 8087))
        app.run(host='0.0.0.0', port=port, debug=False)

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: enhanced-risk-agent
  namespace: default
  labels:
    app: enhanced-risk-agent
    component: ai-credit-scoring
    version: v1.0.0
spec:
  replicas: 1
  selector:
    matchLabels:
      app: enhanced-risk-agent
  template:
    metadata:
      labels:
        app: enhanced-risk-agent
        component: ai-credit-scoring
        version: v1.0.0
    spec:
      containers:
      - name: enhanced-risk-agent
        image: python:3.12-slim
        workingDir: /app
        command: ["/bin/bash", "-c", "pip install flask google-generativeai && python app.py"]
        ports:
        - containerPort: 8087
          name: http
        env:
        - name: PORT
          value: "8087"
        - name: GEMINI_API_KEY
          valueFrom:
            secretKeyRef:
              name: gemini-api-key
              key: api-key
              optional: true
        volumeMounts:
        - name: code
          mountPath: /app
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "100m"
      volumes:
      - name: code
        configMap:
          name: enhanced-risk-agent-code

---
apiVersion: v1
kind: Service
metadata:
  name: enhanced-risk-agent
  namespace: default
  labels:
    app: enhanced-risk-agent
    component: ai-credit-scoring
    version: v1.0.0
spec:
  selector:
    app: enhanced-risk-agent
  ports:
  - port: 8087
    targetPort: 8087
    protocol: TCP
    name: http
  type: ClusterIP

---
# =============================================================================
# TERMS AGENT - CREDIT TERMS GENERATION
# =============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: terms-agent-code
  namespace: default
  labels:
    app: terms-agent
    component: ai-terms-generator
    version: v1.0.0
data:
  app.py: |
    #!/usr/bin/env python3
    """
    Terms Agent - Gemini AI-Powered Credit Terms Generator
    =====================================================
    
    Generates intelligent credit terms using Gemini AI based on risk assessment,
    spending patterns, and banking best practices. Includes comprehensive guardrails
    to prevent undefined values and unrealistic terms.
    """
    
    import os
    import json
    import logging
    from flask import Flask, request, jsonify
    from datetime import datetime
    import google.generativeai as genai
    
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    app = Flask(__name__)
    
    # Initialize Gemini AI
    GEMINI_API_KEY = os.getenv('GEMINI_API_KEY', 'your-api-key-here')
    GEMINI_AVAILABLE = False
    
    if GEMINI_API_KEY and GEMINI_API_KEY != 'your-api-key-here':
        try:
            genai.configure(api_key=GEMINI_API_KEY)
            model = genai.GenerativeModel('gemini-pro')
            GEMINI_AVAILABLE = True
        except Exception as e:
            model = None
    else:
        model = None
    
    def apply_guardrails(terms):
        """Apply comprehensive guardrails to prevent undefined/unrealistic values"""
        # APR Guardrails
        apr_rate = terms.get('apr_rate', 18.99)
        if isinstance(apr_rate, str) or apr_rate is None:
            apr_rate = 18.99
        apr_rate = max(10.99, min(29.99, float(apr_rate)))  # Keep between 10.99% and 29.99%
        apr_rate = round(apr_rate, 2)
        
        # Credit Limit Guardrails
        credit_limit = terms.get('credit_limit', 5000)
        if isinstance(credit_limit, str) or credit_limit is None:
            credit_limit = 5000
        credit_limit = max(1000, min(50000, int(credit_limit)))  # Between $1K and $50K
        
        # Grace Period Guardrails
        grace_period = terms.get('grace_period_days', 25)
        if isinstance(grace_period, str) or grace_period is None:
            grace_period = 25
        grace_period = max(21, min(30, int(grace_period)))  # Between 21-30 days
        
        # Annual Fee Guardrails
        annual_fee = terms.get('annual_fee', 0)
        if isinstance(annual_fee, str) or annual_fee is None:
            annual_fee = 0
        annual_fee = max(0, min(500, int(annual_fee)))  # Between $0 and $500
        
        # Other Fee Guardrails
        late_fee = max(25, min(40, terms.get('late_fee', 35)))
        cash_advance_fee = max(3.0, min(5.0, terms.get('cash_advance_fee', 5.0)))
        foreign_fee = max(0, min(3.0, terms.get('foreign_transaction_fee', 2.7)))
        min_payment = max(1.0, min(3.0, terms.get('minimum_payment_percentage', 2.0)))
        
        return {
            'apr_rate': apr_rate,
            'credit_limit': credit_limit,
            'annual_fee': annual_fee,
            'grace_period_days': grace_period,
            'late_fee': late_fee,
            'cash_advance_fee': cash_advance_fee,
            'foreign_transaction_fee': foreign_fee,
            'minimum_payment_percentage': min_payment,
            'promotional_offers': terms.get('promotional_offers', [])
        }
    
    def generate_terms_with_gemini(risk_data, spending_data):
        """Generate intelligent credit terms using Gemini AI"""
        if not GEMINI_AVAILABLE:
            return generate_fallback_terms(risk_data, spending_data)
        
        try:
            # Prepare context for Gemini
            score = risk_data.get('score', 650)
            tier = risk_data.get('tier', 'Standard')
            total_spending = spending_data.get('total_spending', 1000)
            transaction_count = spending_data.get('transaction_count', 20)
            current_balance = spending_data.get('current_balance', 2500)
            
            prompt = f"""
            As a credit risk expert for Bank of Anthos, generate appropriate credit card terms based on this customer profile:
            
            CUSTOMER PROFILE:
            - Credit Score: {score}
            - Risk Tier: {tier}
            - Monthly Spending: ${total_spending/3:.2f} (over 3 months)
            - Transaction Count: {transaction_count}
            - Current Balance: ${current_balance}
            
            REQUIREMENTS:
            - APR must be between 10.99% and 29.99%
            - Credit limit between $1,000 and $50,000
            - Grace period between 21-30 days
            - Annual fee between $0-500
            - Late fee between $25-40
            - Cash advance fee between 3.0%-5.0%
            - Foreign transaction fee between 0%-3.0%
            - Minimum payment percentage between 1.0%-3.0%
            
            SCORING GUIDELINES:
            - Excellent (750+): Lower APR (10.99-16.99%), higher limits, premium benefits
            - Good (700-749): Moderate APR (16.99-21.99%), standard limits
            - Fair (650-699): Higher APR (21.99-26.99%), lower limits
            - Poor (<650): Highest APR (26.99-29.99%), minimum limits
            
            Return ONLY a JSON object with these exact keys:
            {{
                "apr_rate": 18.99,
                "credit_limit": 15000,
                "annual_fee": 0,
                "grace_period_days": 25,
                "late_fee": 35,
                "cash_advance_fee": 5.0,
                "foreign_transaction_fee": 2.7,
                "minimum_payment_percentage": 2.0,
                "promotional_offers": []
            }}
            """
            
            response = model.generate_content(prompt)
            
            # Parse Gemini response
            response_text = response.text.strip()
            if response_text.startswith('```json'):
                response_text = response_text[7:-3]
            elif response_text.startswith('```'):
                response_text = response_text[3:-3]
            
            terms_data = json.loads(response_text)
            
            # Apply guardrails to Gemini-generated terms
            safe_terms = apply_guardrails(terms_data)
            
            
            return {
                'terms': safe_terms,
                'risk_tier': tier,
                'credit_score_used': score,
                'generation_method': 'gemini_ai',
                'generation_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
        except Exception as e:
            return generate_fallback_terms(risk_data, spending_data)
    
    def generate_fallback_terms(risk_data, spending_data):
        """Generate fallback terms with deterministic logic and guardrails"""
        score = risk_data.get('score', 650)
        tier = risk_data.get('tier', 'Standard')
        total_spending = spending_data.get('total_spending', 1000)
        
        # Deterministic APR calculation with guardrails
        if score >= 750:
            apr_rate = 15.99  # Excellent credit
        elif score >= 700:
            apr_rate = 19.99  # Good credit
        elif score >= 650:
            apr_rate = 24.99  # Fair credit
        else:
            apr_rate = 28.99  # Poor credit
        
        # Credit limit calculation with guardrails
        spending_multiplier = min(max(total_spending / 1000, 1), 10)
        if tier == 'Gold':
            base_limit = 15000
        elif tier == 'Silver':
            base_limit = 10000
        else:
            base_limit = 5000
        
        credit_limit = int(base_limit * spending_multiplier)
        credit_limit = min(credit_limit, 50000)  # Cap at $50k
        credit_limit = max(credit_limit, 1000)   # Minimum $1k
        
        # Other terms with guardrails
        annual_fee = 0 if tier == 'Gold' else (95 if tier == 'Silver' else 0)
        grace_period = 25 if tier in ['Gold', 'Silver'] else 21
        
        terms = {
            'apr_rate': apr_rate,
            'credit_limit': credit_limit,
            'annual_fee': annual_fee,
            'grace_period_days': grace_period,
            'late_fee': 35,
            'cash_advance_fee': 5.0,
            'foreign_transaction_fee': 0 if tier == 'Gold' else 2.7,
            'minimum_payment_percentage': 2.0,
            'promotional_offers': [
                {
                    'title': '0% APR for 12 months',
                    'description': 'No interest on purchases for the first year'
                }
            ] if tier == 'Gold' else []
        }
        
        # Apply final guardrails
        safe_terms = apply_guardrails(terms)
        
        return {
            'terms': safe_terms,
            'risk_tier': tier,
            'credit_score_used': score,
            'generation_method': 'fallback_logic',
            'generation_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
    
    def generate_terms(risk_data, spending_data):
        """Main terms generation function with Gemini AI and fallback"""
        # Input validation and guardrails
        if not risk_data:
            risk_data = {'score': 650, 'tier': 'Standard'}
        if not spending_data:
            spending_data = {'total_spending': 1000, 'transaction_count': 20}
        
        # Ensure required fields exist
        risk_data.setdefault('score', 650)
        risk_data.setdefault('tier', 'Standard')
        spending_data.setdefault('total_spending', 1000)
        spending_data.setdefault('transaction_count', 20)
        spending_data.setdefault('current_balance', 2500)
        
        # Generate terms using Gemini AI with fallback
        if GEMINI_AVAILABLE:
            return generate_terms_with_gemini(risk_data, spending_data)
        else:
            return generate_fallback_terms(risk_data, spending_data)
    
    @app.route('/health')
    def health():
        return jsonify({'status': 'healthy', 'agent': 'terms'})
    
    @app.route('/terms', methods=['POST'])
    def generate_credit_terms():
        try:
            data = request.json
            risk_data = data.get('risk_data', {})
            spending_data = data.get('spending_data', {})
            
            if not risk_data:
                return jsonify({'error': 'Risk data required'}), 400
            
            terms_data = generate_terms(risk_data, spending_data)
            
            return jsonify(terms_data)
            
        except Exception as e:
            return jsonify({'error': 'Terms generation failed'}), 500
    
    if __name__ == '__main__':
        port = int(os.environ.get('PORT', 8086))
        app.run(host='0.0.0.0', port=port, debug=False)

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: terms-agent-simple
  namespace: default
  labels:
    app: terms-agent-simple
    component: ai-terms-generator
    version: v1.0.0
spec:
  replicas: 1
  selector:
    matchLabels:
      app: terms-agent-simple
  template:
    metadata:
      labels:
        app: terms-agent-simple
        component: ai-terms-generator
        version: v1.0.0
    spec:
      containers:
      - name: terms-agent
        image: python:3.12-slim
        workingDir: /app
        command: ["/bin/bash", "-c", "pip install flask google-generativeai && python app.py"]
        ports:
        - containerPort: 8086
          name: http
        env:
        - name: PORT
          value: "8086"
        - name: GEMINI_API_KEY
          valueFrom:
            secretKeyRef:
              name: gemini-api-key
              key: api-key
              optional: true
        volumeMounts:
        - name: code
          mountPath: /app
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "100m"
      volumes:
      - name: code
        configMap:
          name: terms-agent-code

---
apiVersion: v1
kind: Service
metadata:
  name: terms-agent-simple
  namespace: default
  labels:
    app: terms-agent-simple
    component: ai-terms-generator
    version: v1.0.0
spec:
  selector:
    app: terms-agent-simple
  ports:
  - port: 8086
    targetPort: 8086
    protocol: TCP
    name: http
  type: ClusterIP
